        -:    0:Source:UT_Calc_Ab.c
        -:    0:Graph:UT_Calc_Ab.gcno
        -:    0:Data:UT_Calc_Ab.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:/** ==================================================================================================================*\
        -:    2:  @file UT_Calc_Ab.c
        -:    3:
        -:    4:  @brief Testy jednostkowe do Calc_Ab
        -:    5:\*====================================================================================================================*/
        -:    6:#include "Std_Types.h"
        -:    7:
        -:    8:#include "acutest.h"
        -:    9:#include "fff.h"
        -:   10:
        -:   11:#include "Calc_Ab.c"
        -:   12:
        -:   13:#define MAX32   (2147483647L)
        -:   14:#define MIN32   (-2147483648L)
        -:   15:
        -:   16:#define A_ERROR_VALUE  (0xFFFFFFFF)
        -:   17:
        -:   18:DEFINE_FFF_GLOBALS;
        -:   19:
        -:   20:// Mock pamięci kalkulatora
        -:   21:static sint32 memory_value_fake;
        -:   22:
        2:   23:FAKE_VALUE_FUNC(Std_ReturnType, Lib_Calc_Add, sint32, sint32, sint32*);
        2:   24:FAKE_VALUE_FUNC(Std_ReturnType, Lib_Calc_Sub, sint32, sint32, sint32*);
        1:   25:FAKE_VALUE_FUNC(Std_ReturnType, Lib_Calc_Mul, sint32, sint32, sint32*);
        2:   26:FAKE_VALUE_FUNC(Std_ReturnType, Lib_Calc_Div, sint32, sint32, sint32*);
        5:   27:FAKE_VOID_FUNC(Lib_Calc_MemS, sint32);
        4:   28:FAKE_VALUE_FUNC(sint32, Lib_Calc_MemR);
        -:   29:
        -:   30:// Mocki do custom_fake
        2:   31:static Std_ReturnType mock_add_ok(sint32 a, sint32 b, sint32* r) {
        2:   32:    *r = a + b;
        2:   33:    return E_OK;
        -:   34:}
        2:   35:static Std_ReturnType mock_sub_ok(sint32 a, sint32 b, sint32* r) {
        2:   36:    *r = a - b;
        2:   37:    return E_OK;
        -:   38:}
        1:   39:static Std_ReturnType mock_mul_ok(sint32 a, sint32 b, sint32* r) {
        1:   40:    *r = a * b;
        1:   41:    return E_OK;
        -:   42:}
        1:   43:static Std_ReturnType mock_div_ok(sint32 a, sint32 b, sint32* r) {
        1:   44:    *r = b ? a / b : 0;
        1:   45:    return E_OK;
        -:   46:}
        -:   47:
    #####:   48:static Std_ReturnType mock_add_err(sint32 a, sint32 b, sint32* r) {
    #####:   49:    return E_NOT_OK;
        -:   50:}
        -:   51:
    #####:   52:static Std_ReturnType mock_sub_err(sint32 a, sint32 b, sint32* r) {
    #####:   53:    return E_NOT_OK;
        -:   54:}
    #####:   55:static Std_ReturnType mock_mul_err(sint32 a, sint32 b, sint32* r) {
    #####:   56:    *r = 0;
    #####:   57:    return E_NOT_OK;
        -:   58:}
        1:   59:static Std_ReturnType mock_div_err(sint32 a, sint32 b, sint32* r) {
        1:   60:    *r = 0;
        1:   61:    return E_NOT_OK;
        -:   62:}
        -:   63:
        4:   64:static void mock_Lib_Calc_MemS(sint32 mem) {
        4:   65:    memory_value_fake = mem;
        4:   66:}
        -:   67:
        4:   68:static sint32 mock_Lib_Calc_MemR(void) {
        4:   69:    return memory_value_fake;
        -:   70:}
        -:   71:
        -:   72:// -------------------------------------------------------------------------------------------------
        -:   73:
        -:   74:/**
        -:   75:  @brief Test zerowania modułu
        -:   76:
        -:   77:  Funkcja testująca reset modułu.
        -:   78:*/
        1:   79:void Test_Of_Calc_Reset(void)
        -:   80:{
        1:   81:    akumulator = 0xFFFFFFFFL;
        -:   82:
        1:   83:    Calc_Reset();
        -:   84:
        1:   85:    TEST_CHECK(Lib_Calc_MemS_fake.call_count == 1);
        1:   86:    TEST_CHECK(Lib_Calc_MemS_fake.arg0_val == 0L);
        1:   87:    TEST_CHECK(akumulator == 0L);
        1:   88:}
        -:   89:
        -:   90:/**
        -:   91:  @brief Test ustawiania wartości akumulatora
        -:   92:
        -:   93:  Funkcja testująca ustawianie wartości akumulatora.
        -:   94:*/
        1:   95:void Test_Of_Calc_Set_A(void)
        -:   96:{
        1:   97:    akumulator = 0x00000000L;
        -:   98:
        1:   99:    Calc_Set_A(MIN32); 
        1:  100:    TEST_CHECK(akumulator == MIN32);
        -:  101:
        1:  102:    akumulator = 0x00000000L;
        -:  103:
        1:  104:    Calc_Set_A(MAX32);
        1:  105:    TEST_CHECK(akumulator == MAX32);
        -:  106:
        1:  107:    akumulator = A_ERROR_VALUE;
        -:  108:
        1:  109:    Calc_Set_A(0L);    
        1:  110:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        1:  111:}
        -:  112:
        -:  113:/**
        -:  114:  @brief Test odczytu wartości akumulatora
        -:  115:
        -:  116:  Funkcja testująca odczyt wartości akumulatora.
        -:  117:*/
        1:  118:void Test_Of_Calc_Get_A(void)
        -:  119:{
        1:  120:    sint32 a = 0L;
        -:  121:    Std_ReturnType ret;
        -:  122:
        1:  123:    akumulator = 0L;
        1:  124:    ret = Calc_Get_A(&a);
        1:  125:    TEST_CHECK(ret == E_OK);
        1:  126:    TEST_CHECK(a == 0L);
        -:  127:
        1:  128:    akumulator = MAX32;
        1:  129:    ret = Calc_Get_A(&a);
        1:  130:    TEST_CHECK(ret == E_OK);
        1:  131:    TEST_CHECK(a == MAX32);
        -:  132:
        1:  133:    akumulator = MIN32;
        1:  134:    ret = Calc_Get_A(&a);
        1:  135:    TEST_CHECK(ret == E_OK);
        1:  136:    TEST_CHECK(a == MIN32);
        -:  137:
        1:  138:    akumulator = A_ERROR_VALUE;
        1:  139:    ret = Calc_Get_A(&a);
        1:  140:    TEST_CHECK(ret == E_NOT_OK);
        1:  141:    TEST_CHECK(a == A_ERROR_VALUE);
        1:  142:}
        -:  143:
        -:  144:/**
        -:  145:  @brief Test wykonywania operacji arytmetycznych
        -:  146:
        -:  147:  Funkcja testująca wykonywanie operacji arytmetycznych.
        -:  148:*/
        1:  149:void Test_of_Calc_Oper(void)
        -:  150:{
        -:  151:    // Dodawanie OK
        1:  152:    akumulator = 0L;
        1:  153:    Lib_Calc_Add_fake.custom_fake = mock_add_ok;
        1:  154:    Calc_Oper(CALC_ADD, MIN32);
        1:  155:    TEST_CHECK(akumulator == MIN32);
        -:  156:
        -:  157:    // Odejmowanie OK
        1:  158:    akumulator = 0L;
        1:  159:    Lib_Calc_Sub_fake.custom_fake = mock_sub_ok;
        1:  160:    Calc_Oper(CALC_SUB, MAX32);
        1:  161:    TEST_CHECK(akumulator == MIN32+1);                  // +1 bo 0 - 2147483647 = -2147483647 a nie -2147483648 
        -:  162:
        -:  163:    // Mnożenie OK
        1:  164:    akumulator = 2L;
        1:  165:    Lib_Calc_Mul_fake.custom_fake = mock_mul_ok;
        1:  166:    Calc_Oper(CALC_MUL, 3L);
        1:  167:    TEST_CHECK(akumulator == 6L);
        -:  168:
        -:  169:    // Dzielenie OK
        1:  170:    akumulator = 2L;
        1:  171:    Lib_Calc_Div_fake.custom_fake = mock_div_ok;
        1:  172:    Calc_Oper(CALC_DIV, 2L);
        1:  173:    TEST_CHECK(akumulator == 1L);
        -:  174:
        -:  175:    // Dzielenie przez zero (błąd)
        1:  176:    akumulator = 1L;
        1:  177:    Lib_Calc_Div_fake.custom_fake = mock_div_err;
        1:  178:    Calc_Oper(CALC_DIV, 0L); 
        1:  179:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        -:  180:
        -:  181:    // Gdy poprzednia operacja zakończyła się błędem, Dodawanie
        1:  182:    akumulator = A_ERROR_VALUE;
        1:  183:    Lib_Calc_Add_fake.custom_fake = mock_add_ok;
        1:  184:    Calc_Oper(CALC_ADD, 1L); 
        1:  185:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        -:  186:
        -:  187:    // Gdy poprzednia operacja zakończyła się błędem, Odejmowanie
        1:  188:    akumulator = A_ERROR_VALUE;
        1:  189:    Lib_Calc_Sub_fake.custom_fake = mock_sub_ok;
        1:  190:    Calc_Oper(CALC_SUB, 1L);
        1:  191:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        -:  192:
        -:  193:    // Gdy poprzednia operacja zakończyła się błędem, Mnożenie
        1:  194:    akumulator = A_ERROR_VALUE;
        1:  195:    Lib_Calc_Mul_fake.custom_fake = mock_mul_ok;
        1:  196:    Calc_Oper(CALC_MUL, 2L);
        1:  197:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        -:  198:
        -:  199:    //Gdy poprzednia operacja zakończyła się błędem, Dzielenie
        1:  200:    akumulator = A_ERROR_VALUE;
        1:  201:    Lib_Calc_Div_fake.custom_fake = mock_div_ok;
        1:  202:    Calc_Oper(CALC_DIV, 2L);
        1:  203:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        -:  204:
        -:  205:    // Wyłącz custom_fake po teście
        1:  206:    Lib_Calc_Add_fake.custom_fake = NULL;
        1:  207:    Lib_Calc_Sub_fake.custom_fake = NULL;
        1:  208:    Lib_Calc_Mul_fake.custom_fake = NULL;
        1:  209:    Lib_Calc_Div_fake.custom_fake = NULL;
        1:  210:}
        -:  211:
        -:  212:
        -:  213:/**
        -:  214:  @brief Test operacji na pamięci kalkulatora
        -:  215:
        -:  216:  Funkcja testująca operacje na pamięci kalkulatora.
        -:  217:*/
        1:  218:void Test_of_Calc_Mem(void)
        -:  219:{
        1:  220:    Lib_Calc_MemR_fake.custom_fake = mock_Lib_Calc_MemR;
        1:  221:    Lib_Calc_MemS_fake.custom_fake = mock_Lib_Calc_MemS;
        1:  222:    Lib_Calc_Add_fake.custom_fake = mock_add_ok;
        1:  223:    Lib_Calc_Sub_fake.custom_fake = mock_sub_ok;
        -:  224:
        -:  225:    // Dodawanie OK
        1:  226:    memory_value_fake = 0L;
        1:  227:    akumulator = MAX32;
        1:  228:    Calc_Mem(CALC_MEM_ADD);
        1:  229:    TEST_CHECK(memory_value_fake == MAX32);
        -:  230:
        -:  231:    // Odejmowanie OK
        1:  232:    memory_value_fake = 0L;
        1:  233:    akumulator = MAX32;
        1:  234:    Calc_Mem(CALC_MEM_SUB);
        1:  235:    TEST_CHECK(memory_value_fake == MIN32+1);                  // +1 bo 0 - 2147483647 = -2147483647 a nie -2147483648 
        -:  236:
        -:  237:    // Zapis do pamięci OK
        1:  238:    memory_value_fake = 0L;
        1:  239:    akumulator = MAX32;
        1:  240:    Calc_Mem(CALC_MEM_STO);
        1:  241:    TEST_CHECK(memory_value_fake == MAX32);
        -:  242:
        -:  243:    // Wyzerowanie pamięci OK
        1:  244:    memory_value_fake = MAX32;
        1:  245:    akumulator = 0L;
        1:  246:    Calc_Mem(CALC_MEM_ZERO);
        1:  247:    TEST_CHECK(memory_value_fake == 0L);
        -:  248:
        -:  249:    // Gdy poprzednia operacja zakończyła się błędem, Dodawanie
        1:  250:    memory_value_fake = 0L;
        1:  251:    akumulator = A_ERROR_VALUE;
        1:  252:    Calc_Mem(CALC_MEM_ADD); 
        1:  253:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        1:  254:    TEST_CHECK(memory_value_fake == 0L);
        -:  255:
        -:  256:    // Gdy poprzednia operacja zakończyła się błędem, Odejmowanie
        1:  257:    memory_value_fake = 0L;
        1:  258:    akumulator = A_ERROR_VALUE;
        1:  259:    Calc_Mem(CALC_MEM_SUB);
        1:  260:    TEST_CHECK(akumulator == A_ERROR_VALUE);
        1:  261:    TEST_CHECK(memory_value_fake == 0L);
        -:  262:    
        -:  263:    // Wyłącz custom_fake po teście
        1:  264:    Lib_Calc_Add_fake.custom_fake = NULL;
        1:  265:    Lib_Calc_Sub_fake.custom_fake = NULL;
        1:  266:    Lib_Calc_MemR_fake.custom_fake = NULL;
        1:  267:    Lib_Calc_MemS_fake.custom_fake = NULL;
        -:  268:
        1:  269:}
        -:  270:
        -:  271:/*
        -:  272:  Lista testów - wpisz tutaj wszystkie funkcje które mają być wykonane jako testy.
        -:  273:*/
        -:  274:TEST_LIST = {
        -:  275:    { "Test of Calc_Reset", Test_Of_Calc_Reset },         /* Format to { "nazwa testu", nazwa_funkcji } */
        -:  276:    { "Test of Calc_Set_A", Test_Of_Calc_Set_A },
        -:  277:    { "Test of Calc_Get_A", Test_Of_Calc_Get_A },
        -:  278:    { "Test of Calc_Oper", Test_of_Calc_Oper },
        -:  279:    { "Test of Calc_Mem", Test_of_Calc_Mem },
        -:  280:    { NULL, NULL }                                        /* To musi być na końcu */
        -:  281:};
        -:  282:
