        -:    0:Source:Lib_Calc.c
        -:    0:Graph:UT_Lib_Calc.gcno
        -:    0:Data:UT_Lib_Calc.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:/**
        -:    2: * @file Lib_Calc.c
        -:    3: * @brief Implementacja funkcjonalności kalkulatora 4-działaniowego z pamięcią.
        -:    4: * @author pzieba
        -:    5: * @date 2025-10-09
        -:    6: * @see Lib_Calc.pdf
        -:    7: */
        -:    8:
        -:    9:/*====================================================================================================================*\
        -:   10:    Załączenie nagłówków
        -:   11:\*====================================================================================================================*/
        -:   12:#include "Lib_Calc.h"
        -:   13:#include "Std_Types.h"
        -:   14:#include "Platform_Types.h"
        -:   15:
        -:   16:/*====================================================================================================================*\
        -:   17:    Makra lokalne
        -:   18:\*====================================================================================================================*/
        -:   19:
        -:   20:/**
        -:   21: * @def MAX32
        -:   22: * Maksymalna wartość dla typu 32-bitowego.
        -:   23: */
        -:   24:#define MAX32   (2147483647L)
        -:   25:
        -:   26:/**
        -:   27: * @def MIN32
        -:   28: * Minimalna wartość dla typu 32-bitowego.
        -:   29: */
        -:   30:#define MIN32   (-2147483648L)
        -:   31:
        -:   32:/**
        -:   33: * @def DIV_POS_BY_ZERO_RESULT
        -:   34: * Wynik dzielenia przez zero dla liczb dodatnich.
        -:   35: * Realizuje [P6]
        -:   36: */
        -:   37:#define DIV_POS_BY_ZERO_RESULT   (0x7FFFFFFF)
        -:   38:
        -:   39:/**
        -:   40: * @def DIV_NEG_BY_ZERO_RESULT
        -:   41: * Wynik dzielenia przez zero dla liczb ujemnych.
        -:   42: * Realizuje [P7]
        -:   43: */
        -:   44:#define DIV_NEG_BY_ZERO_RESULT   (0x80000000)
        -:   45:
        -:   46:/**
        -:   47: * @def DIV_ZERO_BY_ZERO_RESULT
        -:   48: * Wynik dzielenia przez zero dla zera.
        -:   49: * Realizuje [P8]
        -:   50: */
        -:   51:#define DIV_ZERO_BY_ZERO_RESULT  (0x00000000)
        -:   52:
        -:   53:/*====================================================================================================================*\
        -:   54:    Typy lokalne
        -:   55:\*====================================================================================================================*/
        -:   56:
        -:   57:/*====================================================================================================================*\
        -:   58:    Zmienne globalne
        -:   59:\*====================================================================================================================*/
        -:   60:
        -:   61:/*====================================================================================================================*\
        -:   62:    Zmienne lokalne (statyczne)
        -:   63:\*====================================================================================================================*/
        -:   64:static sint32 memory_value;     /**< Reprezentacja pamięci kalkulatora. Realizuje [P11] */
        -:   65:
        -:   66:/*====================================================================================================================*\
        -:   67:    Deklaracje funkcji lokalnych
        -:   68:\*====================================================================================================================*/
        -:   69:
        -:   70:/*====================================================================================================================*\
        -:   71:    Kod globalnych funkcji inline i makr funkcyjnych
        -:   72:\*====================================================================================================================*/
        -:   73:
        -:   74:/*====================================================================================================================*\
        -:   75:    Kod funkcji
        -:   76:\*====================================================================================================================*/
        -:   77:
        -:   78:
        -:   79:/**
        -:   80: * @brief Dodawanie dwóch liczb 32-bitowych z kontrolą przepełnienia.
        -:   81: * @param[in] arg1 Pierwszy argument
        -:   82: * @param[in] arg2 Drugi argument
        -:   83: * @param[out] result Wskaźnik na wynik
        -:   84: * @return E_OK jeśli operacja zakończona sukcesem, E_NOT_OK w przypadku przepełnienia
        -:   85: * @details Realizuje [P2]
        -:   86: */
        2:   87:Std_ReturnType Lib_Calc_Add(sint32 arg1, sint32 arg2, sint32* result)
        -:   88:{
        2:   89:    sint64 tmp = arg1 + arg2;
        2:   90:    Std_ReturnType ret = E_OK;
        2:   91:    if ((tmp > MAX32) || (tmp < MIN32)) {
    #####:   92:        ret = E_NOT_OK;
        -:   93:    }
        2:   94:    *result = (sint32)tmp;
        2:   95:    return ret;
        -:   96:}
        -:   97:
        -:   98:/**
        -:   99: * @brief Odejmowanie dwóch liczb 32-bitowych z kontrolą przepełnienia.
        -:  100: * @param[in] arg1 Pierwszy argument
        -:  101: * @param[in] arg2 Drugi argument
        -:  102: * @param[out] result Wskaźnik na wynik
        -:  103: * @return E_OK jeśli operacja zakończona sukcesem, E_NOT_OK w przypadku przepełnienia
        -:  104: * @details Realizuje [P3]
        -:  105: */
        2:  106:Std_ReturnType Lib_Calc_Sub(sint32 arg1, sint32 arg2, sint32* result)
        -:  107:{
        2:  108:    sint64 tmp = arg1 - arg2;
        2:  109:    Std_ReturnType ret = E_OK;
        2:  110:    if ((tmp > MAX32) || (tmp < MIN32)) {
    #####:  111:        ret = E_NOT_OK;
        -:  112:    }
        2:  113:    *result = (sint32)tmp;
        2:  114:    return ret;
        -:  115:}
        -:  116:
        -:  117:/**
        -:  118: * @brief Mnożenie dwóch liczb 32-bitowych z kontrolą przepełnienia.
        -:  119: * @param[in] arg1 Pierwszy argument
        -:  120: * @param[in] arg2 Drugi argument
        -:  121: * @param[out] result Wskaźnik na wynik
        -:  122: * @return E_OK jeśli operacja zakończona sukcesem, E_NOT_OK w przypadku przepełnienia
        -:  123: * @details Realizuje [P4]
        -:  124: */
        2:  125:Std_ReturnType Lib_Calc_Mul(sint32 arg1, sint32 arg2, sint32* result)
        -:  126:{
        2:  127:    sint64 tmp = arg1 * arg2;
        2:  128:    Std_ReturnType ret = E_OK;
        2:  129:    if ((tmp > MAX32) || (tmp < MIN32)) {
    #####:  130:        ret = E_NOT_OK;
        -:  131:    }
        2:  132:    *result = (sint32)tmp;
        2:  133:    return ret;
        -:  134:}
        -:  135:
        -:  136:/**
        -:  137: * @brief Dzielenie dwóch liczb 32-bitowych z kontrolą przepełnienia i obsługą dzielenia przez zero.
        -:  138: * @param[in] arg1 Licznik
        -:  139: * @param[in] arg2 Mianownik
        -:  140: * @param[out] result Wskaźnik na wynik
        -:  141: * @return E_OK jeśli operacja zakończona sukcesem, E_NOT_OK w przypadku przepełnienia lub dzielenia przez zero
        -:  142: * @details Realizuje [P5]
        -:  143: */
        4:  144:Std_ReturnType Lib_Calc_Div(sint32 arg1, sint32 arg2, sint32* result)
        -:  145:{
        4:  146:    Std_ReturnType ret = E_OK;
        4:  147:    sint64 tmp = 0;
        -:  148:
        4:  149:    if (arg2 == 0L) {
        3:  150:        if (arg1 > 0L) {
        1:  151:            tmp = DIV_POS_BY_ZERO_RESULT;       /**< Wynik dzielenia przez zero dla liczb dodatnich [P6] */
        2:  152:        } else if (arg1 < 0L) {
        1:  153:             tmp = DIV_NEG_BY_ZERO_RESULT;      /**< Wynik dzielenia przez zero dla liczb ujemnych [P7] */
        -:  154:        } else {
        1:  155:            tmp = DIV_ZERO_BY_ZERO_RESULT;      /**< Wynik dzielenia przez zero dla zera [P8] */
        -:  156:        }
        3:  157:        ret = E_NOT_OK;
        -:  158:
        -:  159:    } else {
        1:  160:        tmp = arg1 / arg2;
        1:  161:        if ((tmp > MAX32) || (tmp < MIN32)) {
    #####:  162:            ret = E_NOT_OK;
        -:  163:        }
        -:  164:   }
        4:  165:    *result = (sint32)tmp;
        4:  166:    return ret;
        -:  167:}
        -:  168:
        -:  169:/**
        -:  170: * @brief Zapisuje wartość do pamięci kalkulatora.
        -:  171: * @param[in] mem Wartość do zapisania
        -:  172: * @details Realizuje [P9]
        -:  173: */
        3:  174:void Lib_Calc_MemS(sint32 mem)
        -:  175:{
        3:  176:    memory_value = mem;
        3:  177:}
        -:  178:
        -:  179:/**
        -:  180: * @brief Odczytuje wartość z pamięci kalkulatora.
        -:  181: * @return Zawartość pamięci
        -:  182: * @details Realizuje [P10]
        -:  183: */
        3:  184:sint32 Lib_Calc_MemR(void)
        -:  185:{
        3:  186:    return memory_value;
        -:  187:}
        -:  188:
        -:  189:
